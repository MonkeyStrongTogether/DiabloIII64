# import re
# import ctypes

# # Function to parse C++ structs from a header file
# def parse_header(header_file):
#     with open(header_file, 'r') as f:
#         content = f.read()

#     # Regular expression to find struct definitions
#     struct_pattern = r'struct\s+(\w+)\s*{([^}]*)};'

#     # Find all struct definitions in the header file
#     struct_matches = re.findall(struct_pattern, content, re.DOTALL)

#     structs = []
#     for match in struct_matches:
#         struct_name = match[0]
#         struct_body = match[1].strip()

#         # Regular expression to find field declarations within the struct body
#         field_pattern = r'(\w+)\s+(\w+);'
#         fields = re.findall(field_pattern, struct_body)

#         # Collect fields with their types
#         field_declarations = []
#         for field_type, field_name in fields:
#             field_declarations.append((field_name, field_type))

#         structs.append((struct_name, field_declarations))

#     return structs

# # Function to convert C++ structs to Python ctypes structures and write them to files
# def convert_and_write_to_files(structs, output_dir="."):
#     ctypes_structs = {}

#     for struct_name, fields in structs:
#         # Define a Python equivalent using ctypes
#         class PythonCtypesStruct(ctypes.Structure):
#             _fields_ = [(field_name, ctypes.c_int) for field_name, field_type in fields]
#             # Replace `ctypes.c_int` with appropriate ctypes type mappings for other types

#         ctypes_structs[struct_name] = PythonCtypesStruct

#         # Write Python code to a file
#         filename = f"{output_dir}/{struct_name}.py"
#         with open(filename, 'w') as f:
#             f.write("# Generated by script\n")
#             f.write("import ctypes\n\n")
#             f.write(f"class {struct_name}(ctypes.Structure):\n")
#             f.write("    _fields_ = [\n")
#             for field_name, field_type in fields:
#                 f.write(f"        ('{field_name}', {get_ctypes_type(field_type)}),\n")
#             f.write("    ]\n")

#     print(f"Conversion completed. Files written to {output_dir}")

# # Helper function to map C++ types to ctypes types
# def get_ctypes_type(cpp_type):
#     type_mapping = {
#         'int': 'ctypes.c_int',
#         'float': 'ctypes.c_float',
#         'double': 'ctypes.c_double',
#         # Add more type mappings as needed
#     }
#     return type_mapping.get(cpp_type, 'ctypes.c_int')  # Default to ctypes.c_int if type is not mapped

# # Example usage
# if __name__ == "__main__":
#     header_file = "C:\\Users\\-\\Documents\\Diablo III\\New folder\\Defs.h"  # Replace with your header file path
#     output_directory = "E:\\Users\\-\\source\\repos\\DiabloIII64\\TEST"  # Replace with your desired output directory
#     parsed_structs = parse_header(header_file)
#     convert_and_write_to_files(parsed_structs, output_directory)

elf_file_path = "E:\\Switch\\DiabloIIINX64ra.nss"

import struct
import os

def extract_file_paths_from_elf(elf_path):
    file_paths = []
    
    with open(elf_path, 'rb') as f:
        # Read ELF header
        elf_header = f.read(64)  # ELF header is typically 64 bytes
        if len(elf_header) < 64:
            raise ValueError("Invalid ELF file: ELF header too short")
        
        if elf_header[0:4] != b'\x7fELF':
            raise ValueError("Not an ELF file")
        
        # Determine ELF class (32-bit or 64-bit)
        elf_class = elf_header[4]
        if elf_class == 1:
            elf_format = '<'  # little-endian
            elf_addr_size = 4
        elif elf_class == 2:
            elf_format = '<'  # little-endian
            elf_addr_size = 8
        else:
            raise ValueError("Unknown ELF class")
        
        # Determine endianness (little-endian or big-endian)
        elf_data = elf_header[5]
        if elf_data == 1:
            elf_format += 'I'  # 32-bit
        elif elf_data == 2:
            elf_format += 'Q'  # 64-bit
        else:
            raise ValueError("Unknown ELF data encoding")
        
        # Read section header table information
        if elf_class == 1:
            sh_offset = struct.unpack(elf_format, elf_header[32:36])[0]
            sh_entry_size = struct.unpack(elf_format[1] + 'H', elf_header[46:48])[0]
        elif elf_class == 2:
            sh_offset = struct.unpack(elf_format, elf_header[40:48])[0]
            sh_entry_size = struct.unpack(elf_format[1] + 'H', elf_header[58:60])[0]
        
        # Locate .debug_line section header
        section_header = b''
        while section_header != b'.debug_line\x00':
            f.seek(sh_offset, 0)
            section_header = f.read(12)
            sh_offset += sh_entry_size
        
        if section_header != b'.debug_line\x00':
            raise ValueError("No .debug_line section found")
        
        # Read .debug_line section header
        section_offset = struct.unpack(elf_format, section_header[4:8])[0]
        section_size = struct.unpack(elf_format, section_header[8:12])[0]
        
        # Parse .debug_line section
        f.seek(section_offset, 0)
        while f.tell() < section_offset + section_size:
            unit_length = struct.unpack(elf_format, f.read(elf_addr_size))[0]
            version = struct.unpack('H', f.read(2))[0]
            header_length = struct.unpack(elf_format[1] + 'I', f.read(4))[0]
            min_instruction_length = struct.unpack('B', f.read(1))[0]
            default_is_stmt = struct.unpack('B', f.read(1))[0]
            line_base = struct.unpack('b', f.read(1))[0]
            line_range = struct.unpack('B', f.read(1))[0]
            opcode_base = struct.unpack('B', f.read(1))[0]
            
            # Directory and file tables
            directories = []
            while True:
                directory = f.read(1)
                if directory == b'\x00':
                    break
                directories.append(directory.decode())
            
            files = []
            while True:
                file_entry = f.read(1)
                if file_entry == b'\x00':
                    break
                files.append(file_entry.decode())
            
            # Read line number program
            while True:
                opcode = struct.unpack('B', f.read(1))[0]
                if opcode == 0:
                    break
                elif opcode == 1:
                    f.read(1)
                elif opcode == 2:
                    f.read(2)
                elif opcode == 3:
                    f.read(4)
                elif opcode == 4:
                    f.read(1)
                elif opcode == 5:
                    f.read(0)
                else:
                    delta_opcode = opcode - opcode_base
                    line_increment = line_base + (delta_opcode % line_range)
                    file_index = delta_opcode // line_range
                    
                    file_name = files[file_index]
                    if len(directories) > 0:
                        directory = directories[file_index]
                    else:
                        directory = ''
                    
                    file_path = os.path.join(directory, file_name)
                    file_paths.append(file_path)
        
    return file_paths

# Example usage
if __name__ == "__main__":
    file_paths = extract_file_paths_from_elf(elf_file_path)
    for file_path in file_paths:
        print(file_path)

